---
import ImageMod from "../ImageMod.astro";

const { slider } = Astro.props;
---

<div class="overflow-hidden relative">
  <div
    class="inf-slider"
    data-inf-scroll-speed="150"
    data-inf-direction="normal"
    data-inf-slide-pause-on-hover="false"
    data-aos="fade-left-sm"
    data-aos-delay={300}
  >
    <div class="inf-slide-track space-x-5 h-full">
      {
        slider.map((s: any) => (
          <div class="inf-slide ">
            <ImageMod
              src={s}
              alt="slider image"
              width={0}
              height={598}
              class="h-[200px] md:h-[400px] lg:h-[598px] w-auto object-cover rounded-3xl"
            />
          </div>
        ))
      }
    </div>
  </div>
</div>

<style>
  @keyframes inf-scroll {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-50%);
    }
  }
  @keyframes inf-scroll-reverse {
    0% {
      transform: translateX(-50%);
    }
    100% {
      transform: translateX(0);
    }
  }

  .inf-slide {
    flex-shrink: 0;
    margin-bottom: 24px;
  }

  .inf-slide-track {
    display: flex;
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    interface SliderOptions {
      scrollSpeed: string;
      direction: "normal" | "reverse";
      pauseOnHover: boolean;
    }

    const sliders: NodeListOf<HTMLElement> =
      document.querySelectorAll(".inf-slider");

    sliders.forEach((slider: HTMLElement) => {
      const options: SliderOptions = {
        scrollSpeed: slider.dataset.infScrollSpeed || "100", // Default scroll speed 100px/s
        direction: (slider.dataset.infDirection === "reverse"
          ? "reverse"
          : "normal") as "normal" | "reverse",
        pauseOnHover: slider.dataset.infSlidePauseOnHover === "true",
      };

      const track: HTMLElement | null =
        slider.querySelector(".inf-slide-track");
      if (!track) return;

      const slides: HTMLCollectionOf<HTMLElement> =
        track.getElementsByClassName(
          "inf-slide",
        ) as HTMLCollectionOf<HTMLElement>;
      const numSlides: number = slides.length;

      if (numSlides === 0) return;

      // Calculate total width of all slides
      let totalWidth = 0;
      const slideWidths: number[] = [];

      Array.from(slides).forEach((slide: HTMLElement) => {
        const width = slide.offsetWidth;
        slideWidths.push(width);
        totalWidth += width;
      });

      // Clone slides
      Array.from(slides).forEach((slide: HTMLElement, index: number) => {
        const clone: Node = slide.cloneNode(true);
        (clone as HTMLElement).style.width = `${slideWidths[index]}px`; // Set explicit width on clones
        track.appendChild(clone);
      });

      // Set track width to accommodate all slides (original + cloned)
      track.style.width = `${totalWidth * 2}px`;

      // Calculate animation duration based on scrollSpeed (pixels per second)
      const scrollSpeed: number = parseFloat(options.scrollSpeed);
      const animationDuration: number = (totalWidth * 2) / scrollSpeed; // time = distance / speed

      // Create a custom property with all slide widths
      const slideWidthsString = slideWidths.join("px ") + "px";
      slider.style.setProperty("--slide-widths", slideWidthsString);

      // Set the animation with calculated duration
      const animationName = `inf-scroll${options.direction === "reverse" ? "-reverse" : ""}`;
      track.style.animation = `${animationName} ${animationDuration}s linear infinite`;

      // Add pause on hover functionality
      if (options.pauseOnHover) {
        slider.addEventListener("mouseenter", () => {
          track.style.animationPlayState = "paused";
        });

        slider.addEventListener("mouseleave", () => {
          track.style.animationPlayState = "running";
        });
      }
    });
  });
</script>
